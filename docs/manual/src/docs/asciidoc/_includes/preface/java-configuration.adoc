
[[jc]]
==  Java配置

在Spring 3.1中为Spring Framework添加了对 http://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/beans.html#beans-java[Java配置]的一般支持。
自Spring Security 3.2以来，已经有了Spring Security Java Configuration支持，使用户无需使用任何XML即可轻松配置Spring Security。

如果您熟悉<<ns-config>>，那么您应该会发现它与Security Java Configuration支持之间的相似之处。

注：Spring Security提供了https://github.com/spring-projects/spring-security/tree/master/samples/javaconfig [示例应用程序]，演示了如何使用Spring Security Java Configuration。

===  Hello Web安全Java配置

第一步是创建我们的Spring Security Java配置。
该配置会创建一个名为`springSecurityFilterChain`的Servlet过滤器，它负责应用程序中的所有安全性（保护应用程序URL，验证提交的用户名和密码，重定向到登录表单等）。
你可以在下面找到Spring Security Java Configuration的最基本的例子：

[[jc-hello-wsca]]
[source,java]
----
import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.context.annotation.*;
import org.springframework.security.config.annotation.authentication.builders.*;
import org.springframework.security.config.annotation.web.configuration.*;

@EnableWebSecurity
public class WebSecurityConfig implements WebMvcConfigurer {

	@Bean
	public UserDetailsService userDetailsService() throws Exception {
		InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
		manager.createUser(User.withDefaultPasswordEncoder().username("user").password("password").roles("USER").build());
		return manager;
	}
}
----

这个配置真的没有太多，但它确实很多。
您可以在下面找到以下功能的摘要：

* 要求对您的应用程序中的每个URL进行身份验证
* 为您生成一个登录表单
* 允许具有*Username* _user_和*Password* _password_的用户使用基于表单的身份验证进行身份验证
* 允许用户注销
*  http://en.wikipedia.org/wiki/Cross-site_request_forgery[CSRF攻击]预防
*  http://en.wikipedia.org/wiki/Session_fixation[会话固定]保护
* 安全标题集成
用于安全请求的**  http://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security[HTTP严格传输安全]
**  http://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx[X-Content-Type的选项]集成
** 高速缓存控制（稍后可由应用程序覆盖，以允许缓存静态资源）
**  http://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx[X-XSS-保护]集成
**  X-​​Frame-Options集成有助于防止 http://en.wikipedia.org/wiki/Clickjacking[点击劫持]
* 与以下Servlet API方法集成
**  http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()[HttpServletRequest的＃getRemoteUser（）]
**  http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()[HttpServletRequest.html＃getUserPrincipal（）]
**  http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)[HttpServletRequest.html＃的isUserInRole（java.lang.String中）]
**  http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String,%20java.lang.String)[HttpServletRequest.html＃login（java.lang.String，java.lang.String）]
**  http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout()[HttpServletRequest.html＃注销（）]

====  AbstractSecurityWebApplicationInitializer

下一步是向战争注册{{0}。
这可以在Servlet 3.0+环境中的 http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-container-config[Spring的WebApplicationInitializer支持]的Java配置中完成。
不出所料，Spring Security提供了一个基类`AbstractSecurityWebApplicationInitializer`，可确保`springSecurityFilterChain`为您注册。
我们使用`AbstractSecurityWebApplicationInitializer`的方式取决于我们是否已经使用Spring，或者Spring Security是我们应用程序中唯一的Spring组件。

*  <<abstractsecuritywebapplicationinitializer-without-existing-spring>>  - 如果您尚未使用Spring，请使用这些说明
*  <<abstractsecuritywebapplicationinitializer-with-spring-mvc>>  - 如果您已经在使用Spring，请使用这些说明

不存在Spring的====  AbstractSecurityWebApplicationInitializer

如果您没有使用Spring或Spring MVC，则需要将`WebSecurityConfig`传递给超类，以确保获取配置。
你可以在下面找到一个例子：

[source,java]
----
import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
	extends AbstractSecurityWebApplicationInitializer {

	public SecurityWebApplicationInitializer() {
		super(WebSecurityConfig.class);
	}
}
----

`SecurityWebApplicationInitializer`将执行以下操作：

* 为应用程序中的每个URL自动注册springSecurityFilterChain过滤器
* 添加加载<<jc-hello-wsca,WebSecurityConfig>>的ContextLoaderListener。

具有Spring MVC的AbstractSecurityWebApplicationInitializer。==== 

如果我们在应用程序的其他地方使用Spring，我们可能已经有一个加载我们的Spring配置的`WebApplicationInitializer`。
如果我们使用以前的配置，我们会得到一个错误。
相反，我们应该使用现有的`ApplicationContext`注册Spring Security。
例如，如果我们使用Spring MVC，我们的`SecurityWebApplicationInitializer`将如下所示：

[source,java]
----
import org.springframework.security.web.context.*;

public class SecurityWebApplicationInitializer
	extends AbstractSecurityWebApplicationInitializer {

}
----

这只会为应用程序中的每个URL注册springSecurityFilterChain过滤器。
之后，我们将确保`WebSecurityConfig`在我们现有的ApplicationInitializer中加载。
例如，如果我们使用Spring MVC，它将被添加到`getRootConfigClasses()`

[[message-web-application-inititializer-java]]
[source,java]
----
public class MvcWebApplicationInitializer extends
		AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class<?>[] getRootConfigClasses() {
		return new Class[] { WebSecurityConfig.class };
	}

	// ... other overrides ...
}
----

[[jc-httpsecurity]]
===  HttpSecurity

迄今为止，我们的<<jc-hello-wsca,WebSecurityConfig>>仅包含有关如何验证用户的信息。
Spring Security如何知道我们想要求所有用户进行身份验证？ Spring Security如何知道我们想要支持基于表单的身份验证？原因是`WebSecurityConfigurerAdapter`在`configure(HttpSecurity http)`方法中提供了一个默认配置，如下所示：

[source,java]
----
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.anyRequest().authenticated()
			.and()
		.formLogin()
			.and()
		.httpBasic();
}
----

上面的默认配置：

* 确保对我们应用程序的任何请求都要求用户进行身份验证
* 允许用户使用基于表单的登录进行身份验证
* 允许用户使用HTTP基本身份验证进行身份验证

您会注意到这个配置与XML命名空间配置非常相似：

[source,xml]
----
<http>
	<intercept-url pattern="/**" access="authenticated"/>
	<form-login />
	<http-basic />
</http>
----

关闭XML标签的Java配置等同于使用允许我们继续配置父项的`and()`方法表示。
如果你阅读代码，这也是有道理的。
我想配置授权请求__并配置表单登录__and__配置HTTP基本认证。

[[jc-form]]
===  Java配置和表单登录
由于我们没有提及任何HTML文件或JSP，因此您可能想知道登录表单从何时被提示登录。
由于Spring Security的默认配置没有明确设置登录页面的URL，因此Spring Security会根据启用的功能自动生成一个URL，并使用处理提交的登录的URL的标准值，用户将默认的目标URL登录后发送到等等。

尽管自动生成的登录页面很方便快速启动和运行，但大多数应用程序都希望提供自己的登录页面。
为此，我们可以更新我们的配置，如下所示：


[source,java]
----
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.anyRequest().authenticated()
			.and()
		.formLogin()
			.loginPage("/login") // <1>
			.permitAll();        // <2>
}
----

<1>更新后的配置指定登录页面的位置。
<2>我们必须授予所有用户（即未经身份验证的用户）访问我们的登录页面。
`formLogin().permitAll()`方法允许所有用户访问与基于表单的登录相关的所有URL。

下面是一个使用JSP实现的用于当前配置的登录页面示例：

注意：下面的登录页面代表我们当前的配置。
如果某些默认设置不能满足我们的需求，我们可以轻松更新我们的配置。

[source,html]
----
<c:url value="/login" var="loginUrl"/>
<form action="${loginUrl}" method="post">       <1>
	<c:if test="${param.error != null}">        <2>
		<p>
			Invalid username and password.
		</p>
	</c:if>
	<c:if test="${param.logout != null}">       <3>
		<p>
			You have been logged out.
		</p>
	</c:if>
	<p>
		<label for="username">Username</label>
		<input type="text" id="username" name="username"/>	<4>
	</p>
	<p>
		<label for="password">Password</label>
		<input type="password" id="password" name="password"/>	<5>
	</p>
	<input type="hidden"                        <6>
		name="${_csrf.parameterName}"
		value="${_csrf.token}"/>
	<button type="submit" class="btn">Log in</button>
</form>
----

<1>发布到`/login`网址的邮件将尝试对用户进行身份验证
<2>如果查询参数`error`存在，则认证尝试失败
<3>如果查询参数`logout`存在，用户已成功注销
<4>用户名必须作为名为__username__的HTTP参数存在
<5>密码必须以名为__password__的HTTP参数
<6>我们必须<<csrf-include-csrf-token>>要了解更多信息，请阅读参考文献的<<csrf>>部分

[[jc-authorize-requests]]
=== 授权请求
我们的示例只需要用户进行身份验证，并已为我们的应用程序中的每个URL完成此操作。
我们可以通过向我们的`http.authorizeRequests()`方法添加多个子项来为我们的网址指定自定义要求。
例如：


[source,java]
----
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()                                                                <1>
			.antMatchers("/resources/**", "/signup", "/about").permitAll()                  <2>
			.antMatchers("/admin/**").hasRole("ADMIN")                                      <3>
			.antMatchers("/db/**").access("hasRole('ADMIN') and hasRole('DBA')")            <4>
			.anyRequest().authenticated()                                                   <5>
			.and()
		// ...
		.formLogin();
}
----

<1> `http.authorizeRequests()`方法有多个孩子，每个匹配者按照他们声明的顺序考虑。
<2>我们指定了任何用户都可以访问的多个网址格式。
具体而言，如果网址以"/resources/"开头，等于"/signup"或等于"/about"，任何用户都可以访问请求。
<3>任何以"/admin/"开头的网址将仅限于拥有角色"ROLE_ADMIN"的用户。
您会注意到，由于我们调用了`hasRole`方法，因此我们不需要指定"ROLE_"前缀。
<4>任何以"/db/"开头的网址都需要用户同时拥有"ROLE_ADMIN"和"ROLE_DBA"。
您会注意到，由于我们使用的是`hasRole`表达式，因此无需指定"ROLE_"前缀。
<5>任何尚未匹配的网址只要求用户进行身份验证

[[jc-logout]]
=== 处理注销

使用`{security-api-url}org/springframework/security/config/annotation/web/configuration/WebSecurityConfigurerAdapter.html[WebSecurityConfigurerAdapter]`时，会自动应用注销功能。
默认情况下，访问网址`/logout`将通过以下方式登录用户：

- 使HTTP会话无效
- 清理已配置的任何RememberMe认证
- 清除`SecurityContextHolder`
- 重定向到`/login?logout`

但是，类似于配置登录功能，您还可以有多种选项来进一步自定义注销要求：

[source,java]
----
protected void configure(HttpSecurity http) throws Exception {
	http
		.logout()                                                                <1>
			.logoutUrl("/my/logout")                                                 <2>
			.logoutSuccessUrl("/my/index")                                           <3>
			.logoutSuccessHandler(logoutSuccessHandler)                              <4>
			.invalidateHttpSession(true)                                             <5>
			.addLogoutHandler(logoutHandler)                                         <6>
			.deleteCookies(cookieNamesToClear)                                       <7>
			.and()
		...
}
----

<1>提供注销支持。
这在使用`WebSecurityConfigurerAdapter`时会自动应用。
<2>触发注销的URL（默认为`/logout`）。
如果启用CSRF保护（默认），则该请求也必须是POST。
有关更多信息，请参阅{security-api-url} org / springframework / security / config / annotation / web / configurers / LogoutConfigurer.html＃logoutUrl-java.lang.String- [JavaDoc]。
<3>发生注销后重定向到的URL。
默认值是`/login?logout`。
有关更多信息，请参阅{security-api-url} org / springframework / security / config / annotation / web / configurers / LogoutConfigurer.html＃logoutSuccessUrl-java.lang.String- [JavaDoc]。
<4>让我们指定一个自定义`LogoutSuccessHandler`。
如果指定，则`logoutSuccessUrl()`被忽略。
有关更多信息，请参阅{security-api-url} org / springframework / security / config / annotation / web / configurers / LogoutConfigurer.html＃logoutSuccessHandler-org.springframework.security.web.authentication.logout.LogoutSuccessHandler- [JavaDoc ]。
<5>指定在注销时是否使`HttpSession`无效。
这是默认的*true*。
配置封面下的{{0}。
有关更多信息，请参阅{security-api-url} org / springframework / security / config / annotation / web / configurers / LogoutConfigurer.html＃invalidateHttpSession-boolean- [JavaDoc]。
<6>添加一个`LogoutHandler`。
`SecurityContextLogoutHandler`默认添加为最后一个`LogoutHandler`。
<7>允许指定在注销成功时删除的cookies的名称。
这是明确添加`CookieClearingLogoutHandler`的快捷方式。

[NOTE]
====
注销当然也可以使用XML名称空间表示法进行配置。
有关更多详细信息，请参阅Spring Security XML命名空间部分中<<nsa-logout, logout element>>的文档。
====

通常，为了自定义注销功能，您可以添加
`{security-api-url}org/springframework/security/web/authentication/logout/LogoutHandler.html[LogoutHandler]`
和/或
`{security-api-url}org/springframework/security/web/authentication/logout/LogoutSuccessHandler.html[LogoutSuccessHandler]`
实现。
对于很多常见的场景，这些处理程序都是根据
涵盖了何时使用流利的API。

[[jc-logout-handler]]
====  LogoutHandler

通常，`{security-api-url}org/springframework/security/web/authentication/logout/LogoutHandler.html[LogoutHandler]`
实现指示能够参与注销处理的类。
预计它们将被调用来执行必要的清理。
因此他们应该
不会抛出异常。
提供了各种实现：

-  {安全API-URL}组织/ springframework的/安全/网络/认证/了rememberMe / PersistentTokenBasedRememberMeServices.html [对PersistentTokenBasedRememberMeServices]
-  {安全API-URL}组织/ springframework的/安全/网络/认证/了rememberMe / TokenBasedRememberMeServices.html [TokenBasedRememberMeServices]
-  {安全API-URL}组织/ springframework的/安全/网络/认证/注销/ CookieClearingLogoutHandler.html [CookieClearingLogoutHandler]
-  {安全API-URL}组织/ springframework的/安全/网络/ CSRF / CsrfLogoutHandler.html [CsrfLogoutHandler]
-  {安全API-URL}组织/ springframework的/安全/网络/认证/注销/ SecurityContextLogoutHandler.html [SecurityContextLogoutHandler]

有关详细信息，请参阅<<remember-me-impls>>。

Fluent API不是直接提供`LogoutHandler`实现，而是提供了快捷方式，它们提供了相应的`LogoutHandler`实现。
例如。 `deleteCookies()`允许指定在注销成功时删除一个或多个Cookie的名称。
与添加`CookieClearingLogoutHandler`相比，这是一条捷径。

[[jc-logout-success-handler]]
====  LogoutSuccessHandler

在`LogoutFilter`成功注销后调用`LogoutSuccessHandler`，以处理例如
重定向或转发到适当的目的地。
请注意，界面与`LogoutHandler`几乎相同，但可能会引发异常。

提供了以下实现：

-  {安全API-URL}组织/ springframework的/安全/网络/认证/注销/ SimpleUrlLogoutSuccessHandler.html [SimpleUrlLogoutSuccessHandler]
-  HttpStatusReturningLogoutSuccessHandler

如上所述，您不需要直接指定`SimpleUrlLogoutSuccessHandler`。
相反，流利的API通过设置`logoutSuccessUrl()`来提供快捷方式。
这将设置封面下的`SimpleUrlLogoutSuccessHandler`。
提供的URL将在注销发生后重定向到。
默认值是`/login?logout`。

REST API类型场景中的`HttpStatusReturningLogoutSuccessHandler`可能很有趣。
取而代之的是在成功注销后重定向到URL，这个`LogoutSuccessHandler`允许您提供一个简单的HTTP状态代码来返回。
如果未配置，则缺省情况下将返回状态代码200。

[[jc-logout-references]]
==== 更多注销相关参考

- <<ns-logout, Logout Handling>>
- <<test-logout, Testing Logout>>
- <<servletapi-logout, HttpServletRequest.logout()>>
- <<remember-me-impls>>
CSRF警告部分中的-  <<csrf-logout, Logging Out>>
- 部分<<cas-singlelogout, Single Logout>>（CAS协议）
-  Spring Security XML命名空间部分中<<nsa-logout, logout element>>的文档

[[jc-webflux]]
===  WebFlux安全

Spring Security的WebFlux支持依赖于`WebFilter`，并且对于Spring WebFlux和Spring WebFlux.Fn也是如此。
你可以找到几个示例应用程序来演示下面的代码：

*  Hello WebFlux {gh-samples-url} / javaconfig / hellowebflux [hellowebflux]
*  Hello WebFlux.Fn {gh-samples-url} / javaconfig / hellowebfluxfn [hellowebfluxfn]
*  Hello WebFlux方法{gh-samples-url} / javaconfig / hellowebflux-method [hellowebflux-method]


==== 最小的WebFlux安全配置

您可以在下面找到最低限度的WebFlux安全配置：

[source,java]
-----
@EnableWebFluxSecurity
public class HelloWebfluxSecurityConfig {

	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		UserDetails user = User.withDefaultPasswordEncoder()
			.username("user")
			.password("user")
			.roles("USER")
			.build();
		return new MapReactiveUserDetailsService(user);
	}
}
-----

此配置提供表单和http基本身份验证，设置授权以要求经过身份验证的用户访问任何页面，设置默认登录页面和默认注销页面，设置与安全性相关的HTTP标头，CSRF保护等。

==== 明确的WebFlux安全配置

您可以在下面找到最小WebFlux安全配置的显式版本：

[source,java]
-----
@EnableWebFluxSecurity
public class HelloWebfluxSecurityConfig {

	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		UserDetails user = User.withDefaultPasswordEncoder()
			.username("user")
			.password("user")
			.roles("USER")
			.build();
		return new MapReactiveUserDetailsService(user);
	}

	@Bean
	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
		http
			.authorizeExchange()
				.anyExchange().authenticated()
				.and()
			.httpBasic().and()
			.formLogin();
		return http.build();
	}
}
-----

该配置明确设置了与我们最小配置相同的所有内容。
从这里您可以轻松地对默认值进行更改。

[[jc-oauth2login]]
===  OAuth 2.0登录

OAuth 2.0登录功能为应用程序提供了让用户通过在OAuth 2.0提供者处使用其现有帐户登录应用程序的功能（例如，
GitHub）或OpenID Connect 1.0 Provider（例如Google）。
OAuth 2.0 Login实现了用例："Login with Google"或"Login with GitHub"。

注意：通过使用https://tools.ietf.org/html/rfc6749#section-4.1[OAuth 2.0授权框架]和 http://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth[OpenID Connect Core 1.0]中指定的*Authorization Code Grant*实现OAuth 2.0登录。

[[jc-oauth2login-sample-boot]]
====  Spring Boot 2.0示例

Spring Boot 2.0为OAuth 2.0登录带来了全面的自动配置功能。

本节介绍如何使用_Google_作为_Authentication Provider_配置{gh-samples-url} / boot / oauth2login [*OAuth 2.0 Login sample*]，并涵盖以下主题：

* <<jc-oauth2login-sample-initial-setup,Initial setup>>
* <<jc-oauth2login-sample-redirect-uri,Setting the redirect URI>>
* <<jc-oauth2login-sample-application-config,Configure `application.yml`>>
* <<jc-oauth2login-sample-boot-application,Boot up the application>>


[[jc-oauth2login-sample-initial-setup]]
===== 初始设置

要使用Google的OAuth 2.0身份验证系统进行登录，您必须在Google API控制台中设置一个项目以获取OAuth 2.0凭据。

注意：用于身份验证的https://developers.google.com/identity/protocols/OpenIDConnect[Google' OAuth 2.0实现]符合 http://openid.net/connect/[OpenID Connect 1.0]规范，并且是 http://openid.net/certification/[OpenID认证]。

按照https://developers.google.com/identity/protocols/OpenIDConnect[OpenID Connect]页上的说明操作，从"Setting up OAuth 2.0"部分开始。

完成"Obtain OAuth 2.0 credentials"指示后，您应该拥有一个新的OAuth客户端，其凭据由客户端ID和客户端密钥组成。

[[jc-oauth2login-sample-redirect-uri]]
===== 设置重定向URI

重定向URI是应用程序中的路径，用户的用户代理在与Google进行身份验证并授予对“同意”页面上的OAuth客户端_（<<jc-oauth2login-sample-initial-setup,created in the previous step>>）_的访问权之后，会将其重定向回。

在"Set a redirect URI"小节中，确保*Authorized redirect URIs*字段设置为`http://localhost:8080/login/oauth2/code/google`。

提示：默认重定向URI模板为`{baseUrl}/login/oauth2/code/{registrationId}`。
*_registrationId_*是<<jc-oauth2login-client-registration,ClientRegistration>>的唯一标识符。

[[jc-oauth2login-sample-application-config]]
===== 配置`application.yml`

现在，您已经拥有了一个带有Google的新OAuth客户端，您需要配置该应用程序以使用OAuth客户端作为_authentication flow_。
要做到这一点：

. 转到`application.yml`并设置以下配置：
+
[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:	<1>
          google:	<2>
            client-id: google-client-id
            client-secret: google-client-secret
----
+
.OAuth客户端属性
====
<1> `spring.security.oauth2.client.registration`是OAuth客户端属性的基本属性前缀。
<2>基本属性前缀后面是<<jc-oauth2login-client-registration,ClientRegistration>>的ID，例如google。
====

. 用您之前创建的OAuth 2.0凭据替换`client-id`和`client-secret`属性中的值。


[[jc-oauth2login-sample-boot-application]]
===== 启动应用程序

启动Spring Boot 2.0示例并转至`http://localhost:8080`。
然后，您被重定向到默认的_auto-generated_登录页面，该页面显示Google的链接。

点击Google链接，然后重定向到Google进行身份验证。

在使用Google帐户凭证进行身份验证后，向您呈现的下一页是“同意”屏幕。
“同意”屏幕会要求您允许或拒绝访问之前创建的OAuth客户端。
点击*Allow*，授权OAuth客户端访问您的电子邮件地址和基本配置文件信息。

此时，OAuth客户端会从 http://openid.net/specs/openid-connect-core-1_0.html#UserInfo[UserInfo端点]中检索您的电子邮件地址和基本配置文件信息，并建立经过验证的会话。

[[jc-oauth2login-client-registration]]
====  ClientRegistration

`ClientRegistration`是向OAuth 2.0或OpenID Connect 1.0 Provider注册的客户端的代表。

客户端注册保存信息，如客户端ID，客户端密码，
授权授权类型，重定向URI，范围，授权URI，令牌URI和其他详细信息。

`ClientRegistration`及其属性定义如下：

[source,java]
----
public final class ClientRegistration {
	private String registrationId;	<1>
	private String clientId;	<2>
	private String clientSecret;	<3>
	private ClientAuthenticationMethod clientAuthenticationMethod;	<4>
	private AuthorizationGrantType authorizationGrantType;	<5>
	private String redirectUriTemplate;	<6>
	private Set<String> scopes;	<7>
	private ProviderDetails providerDetails;
	private String clientName;	<8>

	public class ProviderDetails {
		private String authorizationUri;	<9>
		private String tokenUri;	<10>
		private UserInfoEndpoint userInfoEndpoint;
		private String jwkSetUri;	<11>

		public class UserInfoEndpoint {
			private String uri;	<12>
			private String userNameAttributeName;	<13>

		}
	}
}
----
<1> `registrationId`：唯一标识`ClientRegistration`的标识。
<2> `clientId`：客户端标识符。
<3> `clientSecret`：客户端秘密。
<4> `clientAuthenticationMethod`：用于向提供者验证客户端的方法。
支持的值是*basic*和*post*。
<5> `authorizationGrantType`：OAuth 2.0授权框架定义了四个https://tools.ietf.org/html/rfc6749#section-1.3 [授权]类型。
 支持的值是authorization_code和隐式。
<6> `redirectUriTemplate`：客户端注册的重定向URI，_Authorization Server_重定向最终用户的用户代理
 到最终用户已验证并授权访问客户端后。
 默认的重定向URI模板是`{baseUrl}/login/oauth2/code/{registrationId}`，它支持URI模板变量。
<7> `scopes`：客户端在授权请求流程中请求的范围，例如openid，电子邮件或配置文件。
<8> `clientName`：用于客户端的描述性名称。
该名称可用于某些情况下，例如在自动生成的登录页面中显示客户端的名称时。
<9> `authorizationUri`：授权服务器的授权端点URI。
<10> `tokenUri`：授权服务器的令牌端点URI。
<11> `jwkSetUri`：用于检索https://tools.ietf.org/html/rfc7517[JSON Web Key（JWK）]的URI从授权服务器设置，
 ，其中包含用于验证ID令牌的https://tools.ietf.org/html/rfc7515[JSON Web签名（JWS）]的加密密钥以及可选的UserInfo响应。
<12> `(userInfoEndpoint)uri`：UserInfo端点URI，用于访问经过身份验证的最终用户的声明/属性。
<13> `userNameAttributeName`：在UserInfo Response中返回的属性的名称，该名称引用最终用户的名称或标识符。

[[jc-oauth2login-boot-property-mappings]]
====  Spring Boot 2.0属性映射

下表概述了Spring Boot 2.0 OAuth客户端属性到`ClientRegistration`属性的映射。

|===
| Spring Boot 2.0 | ClientRegistration

|`spring.security.oauth2.client.registration._[registrationId]_`
|`registrationId`

|`spring.security.oauth2.client.registration._[registrationId]_.client-id`
|`clientId`

|`spring.security.oauth2.client.registration._[registrationId]_.client-secret`
|`clientSecret`

|`spring.security.oauth2.client.registration._[registrationId]_.client-authentication-method`
|`clientAuthenticationMethod`

|`spring.security.oauth2.client.registration._[registrationId]_.authorization-grant-type`
|`authorizationGrantType`

|`spring.security.oauth2.client.registration._[registrationId]_.redirect-uri-template`
|`redirectUriTemplate`

|`spring.security.oauth2.client.registration._[registrationId]_.scope`
|`scopes`

|`spring.security.oauth2.client.registration._[registrationId]_.client-name`
|`clientName`

|`spring.security.oauth2.client.provider._[providerId]_.authorization-uri`
|`providerDetails.authorizationUri`

|`spring.security.oauth2.client.provider._[providerId]_.token-uri`
|`providerDetails.tokenUri`

|`spring.security.oauth2.client.provider._[providerId]_.jwk-set-uri`
|`providerDetails.jwkSetUri`

|`spring.security.oauth2.client.provider._[providerId]_.user-info-uri`
|`providerDetails.userInfoEndpoint.uri`

|`spring.security.oauth2.client.provider._[providerId]_.userNameAttribute`
|`providerDetails.userInfoEndpoint.userNameAttributeName`
|===

[[jc-oauth2login-client-registration-repo]]
====  ClientRegistrationRepository

`ClientRegistrationRepository`充当OAuth 2.0 / OpenID Connect 1.0 `ClientRegistration`（s）的存储库。

[NOTE]
客户端注册信息最终由关联的授权服务器存储和拥有。
该存储库提供了检索主要客户端注册信息的子集的能力，
它与授权服务器一起存储。

Spring Boot 2.0自动配置绑定`spring.security.oauth2.client.registration._[registrationId]_`下的每个属性
到`ClientRegistration`的实例，然后在`ClientRegistrationRepository`内组合`ClientRegistration`个实例中的每个实例。

[NOTE]
`ClientRegistrationRepository`的默认实现是`InMemoryClientRegistrationRepository`。

自动配置还将`ClientRegistrationRepository`注册为`ApplicationContext`中的`@Bean`
以便它可用于依赖注入，如果应用程序需要的话。

以下列表显示了一个示例：

[source,java]
----
@Controller
public class OAuth2LoginController {

	@Autowired
	private ClientRegistrationRepository clientRegistrationRepository;

	@RequestMapping("/")
	public String index() {
		ClientRegistration googleRegistration =
			this.clientRegistrationRepository.findByRegistrationId("google");

		...

		return "index";
	}
}
----

[[jc-oauth2login-common-oauth2-provider]]
====  CommonOAuth2Provider

`CommonOAuth2Provider`为众多知名供应商预先定义了一组默认客户端属性：Google，GitHub，Facebook和Okta。

例如，`authorization-uri`，`token-uri`和`user-info-uri`不会经常更改提供者。
因此，提供默认值以减少所需的配置是有意义的。

如前所述，当我们<<jc-oauth2login-sample-application-config,configured a Google client>>时，只需要`client-id`和`client-secret`属性。

以下列表显示了一个示例：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: google-client-id
            client-secret: google-client-secret
----

[TIP]
由于`registrationId`（`google`）与`CommonOAuth2Provider`中的`GOOGLE` `enum`（不区分大小写）匹配，所以客户端属性的自动默认功能无缝工作。

对于您可能需要指定不同的`registrationId`的情况，例如`google-login`，
您仍然可以通过配置`provider`属性来利用客户端属性的自动默认功能。

以下列表显示了一个示例：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          google-login:	<1>
            provider: google	<2>
            client-id: google-client-id
            client-secret: google-client-secret
----
<1> `registrationId`设置为`google-login`。
<2> `provider`属性设置为`google`，该属性将利用`CommonOAuth2Provider.GOOGLE.getBuilder()`中设置的客户端属性的自动默认设置。

[[jc-oauth2login-custom-provider-properties]]
==== 配置自定义提供程序属性

有一些OAuth 2.0提供商支持多租户，这会为每个租户（或子域）生成不同的协议端点。

例如，向Okta注册的OAuth客户端分配给特定的子域，并拥有自己的协议端点。

对于这些情况，Spring Boot 2.0为配置自定义提供程序属性提供以下基本属性：`spring.security.oauth2.client.provider._[providerId]_`。

以下列表显示了一个示例：

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
        provider:
          okta:	<1>
            authorization-uri: https://your-subdomain.oktapreview.com/oauth2/v1/authorize
            token-uri: https://your-subdomain.oktapreview.com/oauth2/v1/token
            user-info-uri: https://your-subdomain.oktapreview.com/oauth2/v1/userinfo
            user-name-attribute: sub
            jwk-set-uri: https://your-subdomain.oktapreview.com/oauth2/v1/keys
----

<1>基本属性（`spring.security.oauth2.client.provider.okta`）允许自定义配置协议端点位置。

[[jc-oauth2login-override-boot-autoconfig]]
==== 重写Spring Boot 2.0自动配置

用于OAuth客户端支持的Spring Boot 2.0自动配置类为`OAuth2ClientAutoConfiguration`。

它执行以下任务：

* 从配置的OAuth客户端属性中注册由`ClientRegistration`（s）组成的`ClientRegistrationRepository` `@Bean`。
* 提供`WebSecurityConfigurerAdapter` `@Configuration`并通过`httpSecurity.oauth2Login()`启用OAuth 2.0登录。

如果您需要根据您的特定要求覆盖自动配置，可以通过以下方式进行：

* <<jc-oauth2login-register-clientregistrationrepository-bean,Register a `ClientRegistrationRepository` `@Bean`>>
* <<jc-oauth2login-provide-websecurityconfigureradapter,Provide a `WebSecurityConfigurerAdapter`>>
* <<jc-oauth2login-completely-override-autoconfiguration,Completely Override the Auto-configuration>>


[[jc-oauth2login-register-clientregistrationrepository-bean]]
===== 注册一个`ClientRegistrationRepository` `@Bean`

以下示例显示如何注册`ClientRegistrationRepository` `@Bean`：

[source,java]
----
@Configuration
public class OAuth2LoginConfig {

	@Bean
	public ClientRegistrationRepository clientRegistrationRepository() {
		return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
	}

	private ClientRegistration googleClientRegistration() {
		return ClientRegistration.withRegistrationId("google")
			.clientId("google-client-id")
			.clientSecret("google-client-secret")
			.clientAuthenticationMethod(ClientAuthenticationMethod.BASIC)
			.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
			.redirectUriTemplate("{baseUrl}/login/oauth2/code/{registrationId}")
			.scope("openid", "profile", "email", "address", "phone")
			.authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
			.tokenUri("https://www.googleapis.com/oauth2/v4/token")
			.userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
			.userNameAttributeName(IdTokenClaimNames.SUB)
			.jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
			.clientName("Google")
			.build();
	}
}
----


[[jc-oauth2login-provide-websecurityconfigureradapter]]
===== 提供`WebSecurityConfigurerAdapter`

以下示例显示如何为`WebSecurityConfigurerAdapter`提供`@EnableWebSecurity`，并通过`httpSecurity.oauth2Login()`启用OAuth 2.0登录：

[source,java]
----
@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests()
				.anyRequest().authenticated()
				.and()
			.oauth2Login();
	}
}
----


[[jc-oauth2login-completely-override-autoconfiguration]]
===== 完全覆盖自动配置

以下示例显示了如何通过注册`ClientRegistrationRepository` `@Bean`并提供`WebSecurityConfigurerAdapter`完全覆盖自动配置，两者均在前两节中进行了介绍。

[source,java]
----
@Configuration
public class OAuth2LoginConfig {

	@EnableWebSecurity
	public static class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.authorizeRequests()
					.anyRequest().authenticated()
					.and()
				.oauth2Login();
		}
	}

	@Bean
	public ClientRegistrationRepository clientRegistrationRepository() {
		return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
	}

	private ClientRegistration googleClientRegistration() {
		return ClientRegistration.withRegistrationId("google")
			.clientId("google-client-id")
			.clientSecret("google-client-secret")
			.clientAuthenticationMethod(ClientAuthenticationMethod.BASIC)
			.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
			.redirectUriTemplate("{baseUrl}/login/oauth2/code/{registrationId}")
			.scope("openid", "profile", "email", "address", "phone")
			.authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
			.tokenUri("https://www.googleapis.com/oauth2/v4/token")
			.userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
			.userNameAttributeName(IdTokenClaimNames.SUB)
			.jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
			.clientName("Google")
			.build();
	}
}
----

[[jc-oauth2login-javaconfig-wo-boot]]
没有Spring Boot 2.0的====  Java配置

如果您无法使用Spring Boot 2.0并希望在`CommonOAuth2Provider`中配置一个预定义提供程序（例如Google），请应用以下配置：

[source,java]
----
@Configuration
public class OAuth2LoginConfig {

	@EnableWebSecurity
	public static class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.authorizeRequests()
					.anyRequest().authenticated()
					.and()
				.oauth2Login();
		}
	}

	@Bean
	public ClientRegistrationRepository clientRegistrationRepository() {
		return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
	}

	@Bean
	public OAuth2AuthorizedClientService authorizedClientService() {
		return new InMemoryOAuth2AuthorizedClientService(this.clientRegistrationRepository());
	}

	private ClientRegistration googleClientRegistration() {
		return CommonOAuth2Provider.GOOGLE.getBuilder("google")
			.clientId("google-client-id")
			.clientSecret("google-client-secret")
			.build();
	}
}
----

[[jc-oauth2login-authorized-client]]
====  OAuth2AuthorizedClient / OAuth2AuthorizedClientService

`OAuth2AuthorizedClient`是授权客户端的代表。
当最终用户（资源所有者）授予客户端访问其受保护资源的权限时，客户端被认为是被授权的。

`OAuth2AuthorizedClient`用于将`OAuth2AccessToken`与`ClientRegistration`（客户端）和资源所有者关联起来，该所有者是授予授权的`Principal`最终用户。

`OAuth2AuthorizedClientService`的主要作用是管理`OAuth2AuthorizedClient`个实例。
从开发人员的角度来看，它提供了查找与客户端关联的`OAuth2AccessToken`的功能，以便它可以用来发起对资源服务器的请求。

[NOTE]
Spring Boot 2.0自动配置在`ApplicationContext`中注册`OAuth2AuthorizedClientService` `@Bean`。

开发人员还可以在`ApplicationContext`（覆盖Spring Boot 2.0自动配置）中注册`OAuth2AuthorizedClientService` `@Bean`，以便能够查找与特定相关的`OAuth2AccessToken` `ClientRegistration`（客户端）。

以下列表显示了一个示例：

[source,java]
----
@Controller
public class OAuth2LoginController {

	@Autowired
	private OAuth2AuthorizedClientService authorizedClientService;

	@RequestMapping("/userinfo")
	public String userinfo(OAuth2AuthenticationToken authentication) {
		// authentication.getAuthorizedClientRegistrationId() returns the
		// registrationId of the Client that was authorized during the Login flow
		OAuth2AuthorizedClient authorizedClient =
			this.authorizedClientService.loadAuthorizedClient(
				authentication.getAuthorizedClientRegistrationId(),
				authentication.getName());

		OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

		...

		return "userinfo";
	}
}
----


[[jc-oauth2login-resources]]
==== 其他资源

以下其他资源介绍了高级配置选项：

* <<oauth2login-advanced-login-page, OAuth 2.0 Login Page>>
* 授权端点：
** <<oauth2login-advanced-authorization-request-repository, AuthorizationRequestRepository>>
* <<oauth2login-advanced-redirection-endpoint, Redirection Endpoint>>
* 令牌端点：
** <<oauth2login-advanced-token-client, OAuth2AccessTokenResponseClient>>
*  UserInfo端点：
** <<oauth2login-advanced-map-authorities, Mapping User Authorities>>
** <<oauth2login-advanced-custom-user, Configuring a Custom OAuth2User>>
** <<oauth2login-advanced-oauth2-user-service, OAuth 2.0 UserService>>
** <<oauth2login-advanced-oidc-user-service, OpenID Connect 1.0 UserService>>

[[jc-authentication]]
=== 认证

到目前为止，我们只看到了最基本的认证配置。
让我们来看看几个稍微更高级的配置认证选项。

[[jc-authentication-inmemory]]
==== 内存认证

我们已经看到了为单个用户配置内存认证的例子。
以下是配置多个用户的示例：

[source,java]
----
@Bean
public UserDetailsService userDetailsService() throws Exception {
	// ensure the passwords are encoded properly
	UserBuilder users = User.withDefaultPasswordEncoder();
	InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
	manager.createUser(users.username("user").password("password").roles("USER").build());
	manager.createUser(users.username("admin").password("password").roles("USER","ADMIN").build());
	return manager;
}
----

[[jc-authentication-jdbc]]
====  JDBC身份验证

您可以找到更新以支持基于JDBC的身份验证。
以下示例假定您已经在应用程序中定义了`DataSource`。
https://github.com/spring-projects/spring-security/tree/master/samples/javaconfig/jdbc[jdbc-javaconfig]示例提供了使用基于JDBC的身份验证的完整示例。

[source,java]
----
@Autowired
private DataSource dataSource;

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
	// ensure the passwords are encoded properly
	UserBuilder users = User.withDefaultPasswordEncoder();
	auth
		.jdbcAuthentication()
			.dataSource(dataSource)
			.withDefaultSchema()
			.withUser(users.username("user").password("password").roles("USER"))
			.withUser(users.username("admin").password("password").roles("USER","ADMIN"));
}
----

====  LDAP身份验证

您可以找到更新以支持基于LDAP的身份验证。
https://github.com/spring-projects/spring-security/tree/master/samples/javaconfig/ldap[ldap-javaconfig]示例提供了使用基于LDAP的身份验证的完整示例。

[source,java]
----
@Autowired
private DataSource dataSource;

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
	auth
		.ldapAuthentication()
			.userDnPatterns("uid={0},ou=people")
			.groupSearchBase("ou=groups");
}
----

上面的示例使用以下LDIF和嵌入式Apache DS LDAP实例。

.users.ldif
----
dn: ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: groups

dn: ou=people,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: people

dn: uid=admin,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Rod Johnson
sn: Johnson
uid: admin
userPassword: password

dn: uid=user,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Dianne Emu
sn: Emu
uid: user
userPassword: password

dn: cn=user,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: user
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org
uniqueMember: uid=user,ou=people,dc=springframework,dc=org

dn: cn=admin,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: admin
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org
----

[[jc-authentication-authenticationprovider]]
==== 的AuthenticationProvider

您可以通过将自定义`AuthenticationProvider`公开为bean来定义自定义身份验证。
例如，假设`SpringAuthenticationProvider`实现`AuthenticationProvider`，以下将自定义认证：

注：仅当`AuthenticationManagerBuilder`尚未填充时才会使用

[source,java]
----
@Bean
public SpringAuthenticationProvider springAuthenticationProvider() {
	return new SpringAuthenticationProvider();
}
----

[[jc-authentication-userdetailsservice]]
==== 的UserDetailsS​​ervice

您可以通过将自定义`UserDetailsService`公开为bean来定义自定义身份验证。
例如，假设`SpringDataUserDetailsService`实现`UserDetailsService`，以下将自定义认证：

注意：仅当`AuthenticationManagerBuilder`尚未填充且未定义`AuthenticationProviderBean`时才会使用此选项。

[source,java]
----
@Bean
public SpringDataUserDetailsService springDataUserDetailsService() {
	return new SpringDataUserDetailsService();
}
----

您还可以通过将`PasswordEncoder`公开为bean来自定义密码的编码方式。
例如，如果您使用bcrypt，则可以添加一个bean定义，如下所示：

[source,java]
----
@Bean
public BCryptPasswordEncoder passwordEncoder() {
	return new BCryptPasswordEncoder();
}
----

=== 多个HttpSecurity

我们可以配置多个HttpSecurity实例，就像我们可以有多个`<http>`块一样。
关键是多次扩展`WebSecurityConfigurationAdapter`。
例如，以下是针对以`/api/`开头的URL进行不同配置的示例。

[source,java]
----
@EnableWebSecurity
public class MultiHttpSecurityConfig {
	@Bean                                                             <1>
	public UserDetailsService userDetailsService() throws Exception {
		// ensure the passwords are encoded properly
		UserBuilder users = User.withDefaultPasswordEncoder();
		InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
		manager.createUser(users.username("user").password("password").roles("USER").build());
		manager.createUser(users.username("admin").password("password").roles("USER","ADMIN").build());
		return manager;
	}

	@Configuration
	@Order(1)                                                        <2>
	public static class ApiWebSecurityConfigurationAdapter extends WebSecurityConfigurerAdapter {
		protected void configure(HttpSecurity http) throws Exception {
			http
				.antMatcher("/api/**")                               <3>
				.authorizeRequests()
					.anyRequest().hasRole("ADMIN")
					.and()
				.httpBasic();
		}
	}

	@Configuration                                                   <4>
	public static class FormLoginWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {

		@Override
		protected void configure(HttpSecurity http) throws Exception {
			http
				.authorizeRequests()
					.anyRequest().authenticated()
					.and()
				.formLogin();
		}
	}
}
----

<1>配置身份验证正常
<2>创建包含`@Order`的`WebSecurityConfigurerAdapter`的实例，以指定首先考虑哪个`WebSecurityConfigurerAdapter`。
<3> `http.antMatcher`声明，此`HttpSecurity`仅适用于以`/api/`开头的网址
<4>创建`WebSecurityConfigurerAdapter`的另一个实例。
如果网址不是以`/api/`开头，则会使用此配置。
`ApiWebSecurityConfigurationAdapter`之后会考虑此配置，因为`1`（`@Order`默认为最后一个值）后有`@Order`值。


[[jc-method]]
=== 方法安全性

从2.0版本开始，Spring Security已经大大改善了对服务层方法的安全性的支持。
它提供对JSR-250注释安全性的支持以及框架的原始`@Secured`注释。
从3.0开始，您还可以使用新的<<el-access,expression-based annotations>>。
您可以使用`intercept-methods`元素来装饰bean声明，也可以将安全性应用于单个bean，也可以使用AspectJ样式切入点在整个服务层中保护多个bean。

====  EnableGlobalMethodSecurity

我们可以在任何`@Configuration`实例上使用`@EnableGlobalMethodSecurity`注释来启用基于注释的安全性。
例如，以下内容将启用Spring Security的`@Secured`注释。

[source,java]
----
@EnableGlobalMethodSecurity(securedEnabled = true)
public class MethodSecurityConfig {
// ...
}
----

然后向方法（在类或接口上）添加注释将相应地限制对该方法的访问。
Spring Security的本地注释支持为该方法定义了一组属性。
这些将被传递给AccessDecisionManager以供它作出实际的决定：

[source,java]
----
public interface BankService {

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id);

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts();

@Secured("ROLE_TELLER")
public Account post(Account account, double amount);
}
----

可以使用支持JSR-250注释

[source,java]
----
@EnableGlobalMethodSecurity(jsr250Enabled = true)
public class MethodSecurityConfig {
// ...
}
----

这些都是基于标准的，允许应用简单的基于角色的约束，但是没有Spring Security的本地注释的强大功能。
要使用新的基于表达式的语法，您可以使用

[source,java]
----
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig {
// ...
}
----

和等效的Java代码将会是

[source,java]
----
public interface BankService {

@PreAuthorize("isAnonymous()")
public Account readAccount(Long id);

@PreAuthorize("isAnonymous()")
public Account[] findAccounts();

@PreAuthorize("hasAuthority('ROLE_TELLER')")
public Account post(Account account, double amount);
}
----

====  GlobalMethodSecurityConfiguration

有时您可能需要执行比`@EnableGlobalMethodSecurity`批注允许的操作更复杂的操作。
对于这些实例，您可以扩展`GlobalMethodSecurityConfiguration`，确保`@EnableGlobalMethodSecurity`注释存在于您的子类中。
例如，如果您想提供自定义`MethodSecurityExpressionHandler`，则可以使用以下配置：

[source,java]
----
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
	@Override
	protected MethodSecurityExpressionHandler createExpressionHandler() {
		// ... create and return custom MethodSecurityExpressionHandler ...
		return expressionHandler;
	}
}
----

有关可覆盖的方法的其他信息，请参阅`GlobalMethodSecurityConfiguration` Javadoc。

[[jc-erms]]
====  EnableReactiveMethodSecurity

Spring Security通过使用`ReactiveSecurityContextHolder`设置的https://projectreactor.io/docs/core/release/reference/#context[Reactor's Context]支持方法安全性。
例如，这将演示如何检索当前登录的用户的消息。

[NOTE]
====
为此，该方法的返回类型必须是`org.reactivestreams.Publisher`（即`Mono` / `Flux`）。
这对于整合反应堆的`Context`是必要的。
====

[source,java]
----
Authentication authentication = new TestingAuthenticationToken("user", "password", "ROLE_USER");

Mono<String> messageByUsername = ReactiveSecurityContextHolder.getContext()
	.map(SecurityContext::getAuthentication)
	.map(Authentication::getName)
	.flatMap(this::findMessageByUsername)
	// In a WebFlux application the `subscriberContext` is automatically setup using `ReactorContextWebFilter`
	.subscriberContext(ReactiveSecurityContextHolder.withAuthentication(authentication));

StepVerifier.create(messageByUsername)
	.expectNext("Hi user")
	.verifyComplete();
----

与`this::findMessageByUsername`定义为：

[source,java]
----
Mono<String> findMessageByUsername(String username) {
	return Mono.just("Hi " + username);
}
----

以下是在反应式应用程序中使用方法安全性时的最小方法安全配置。

[source,java]
----
@EnableReactiveMethodSecurity
public class SecurityConfig {
	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();
		UserDetails rob = userBuilder.username("rob").password("rob").roles("USER").build();
		UserDetails admin = userBuilder.username("admin").password("admin").roles("USER","ADMIN").build();
		return new MapReactiveUserDetailsService(rob, admin);
	}
}
----

考虑以下课程：

[source,java]
----
@Component
public class HelloWorldMessageService {
	@PreAuthorize("hasRole('ADMIN')")
	public Mono<String> findMessage() {
		return Mono.just("Hello World!");
	}
}
----

结合上述配置，`@PreAuthorize("hasRole('ADMIN')")`将确保`findByMessage`仅由具有角色`ADMIN`的用户调用。
请注意，标准方法安全性中的任何表达式都适用于`@EnableReactiveMethodSecurity`。
但是，目前我们只支持表达式的`Boolean`或`boolean`的返回类型。
这意味着表达式不能阻止。

当与<<jc-webflux>>进行集成时，Spring Security会根据经过验证的用户自动建立Reactor Context。

[source,java]
----
@EnableWebFluxSecurity
@EnableReactiveMethodSecurity
public class SecurityConfig {

	@Bean
	SecurityWebFilterChain springWebFilterChain(ServerHttpSecurity http) throws Exception {
		return http
			// Demonstrate that method security works
			// Best practice to use both for defense in depth
			.authorizeExchange()
				.anyExchange().permitAll()
				.and()
			.httpBasic().and()
			.build();
	}

	@Bean
	MapReactiveUserDetailsService userDetailsService() {
		User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();
		UserDetails rob = userBuilder.username("rob").password("rob").roles("USER").build();
		UserDetails admin = userBuilder.username("admin").password("admin").roles("USER","ADMIN").build();
		return new MapReactiveUserDetailsService(rob, admin);
	}
}

----

您可以在{gh-samples-url} / javaconfig / hellowebflux-method [hellowebflux-method]中找到完整的示例

=== 后处理配置的对象

Spring Security的Java配置不公开它配置的每个对象的每个属性。
这简化了大多数用户的配置。
最后，如果每个属性都暴露出来，用户可以使用标准的bean配置。

尽管没有直接公开每个属性的很好理由，但用户可能仍然需要更高级的配置选项。
为了解决这个问题，Spring Security引入了`ObjectPostProcessor`的概念，它可以用来修改或替换由Java配置创建的许多对象实例。
例如，如果您想在`FilterSecurityInterceptor`上配置`filterSecurityPublishAuthorizationSuccess`属性，则可以使用以下内容：

[source,java]
----
@Override
protected void configure(HttpSecurity http) throws Exception {
	http
		.authorizeRequests()
			.anyRequest().authenticated()
			.withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {
				public <O extends FilterSecurityInterceptor> O postProcess(
						O fsi) {
					fsi.setPublishAuthorizationSuccess(true);
					return fsi;
				}
			});
}
----

[[jc-custom-dsls]]
=== 自定义DSL

您可以在Spring Security中提供您自己的定制DSL。
例如，你可能有这样的东西：

[source,java]
----
public class MyCustomDsl extends AbstractHttpConfigurer<MyCustomDsl, HttpSecurity> {
	private boolean flag;

	@Override
	public void init(H http) throws Exception {
		// any method that adds another configurer
		// must be done in the init method
		http.csrf().disable();
	}

	@Override
	public void configure(H http) throws Exception {
		ApplicationContext context = http.getSharedObject(ApplicationContext.class);

		// here we lookup from the ApplicationContext. You can also just create a new instance.
		MyFilter myFilter = context.getBean(MyFilter.class);
		myFilter.setFlag(flag);
		http.addFilterBefore(myFilter, UsernamePasswordAuthenticationFilter.class);
	}

	public MyCustomDsl flag(boolean value) {
		this.flag = value;
		return this;
	}

	public static MyCustomDsl customDsl() {
		return new MyCustomDsl();
	}
}
----

注意：这实际上是如何实现像`HttpSecurity.authorizeRequests()`这样的方法。

自定义DSL可以像这样使用：

[source,java]
----
@EnableWebSecurity
public class Config extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.apply(customDsl())
				.flag(true)
				.and()
			...;
	}
}
----

代码按以下顺序调用：

在`Config`的configure方法中调用* 代码
在`MyCustomDsl`的init方法中调用* 代码
在`MyCustomDsl`的configure方法中调用* 代码

如果需要，可以使用`SpringFactories`默认`WebSecurityConfiguerAdapter`添加`MyCustomDsl`。
例如，您将在名为`META-INF/spring.factories`的类路径中创建资源，其中包含以下内容：

.META-INF / spring.factories
----
org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer = sample.MyCustomDsl
----

希望禁用默认的用户可以明确地这样做。

[source,java]
----
@EnableWebSecurity
public class Config extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.apply(customDsl()).disable()
			...;
	}
}
----
